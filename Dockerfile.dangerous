# MeterScience DANGEROUS Autonomous Execution Sandbox
# ‚ö†Ô∏è WARNING: ZERO security restrictions - development only
#
# Build:  docker build -t meterscience-dangerous -f Dockerfile.dangerous .
# Run:    docker run -it --privileged --net=host -v $(pwd):/workspace meterscience-dangerous
# Auto:   docker run --privileged meterscience-dangerous /workspace/scripts/auto-execute.sh

FROM ubuntu:24.04

LABEL maintainer="EcoWorks"
LABEL description="DANGEROUS: Zero-restriction autonomous dev sandbox"

# No prompts, no restrictions
ENV DEBIAN_FRONTEND=noninteractive
ENV TZ=America/Toronto
ENV PYTHONUNBUFFERED=1
ENV PYTHONDONTWRITEBYTECODE=1
ENV NODE_ENV=development
ENV PATH="/root/.cargo/bin:/usr/local/go/bin:/root/go/bin:/root/.local/bin:${PATH}"

# Root access
RUN echo 'root:danger' | chpasswd

# ============================================
# INSTALL EVERYTHING
# ============================================

RUN apt-get update && apt-get install -y \
    build-essential cmake ninja-build pkg-config git curl wget \
    python3 python3-full python3-pip python3-venv python3-dev python3-opencv \
    ruby ruby-dev postgresql-client sqlite3 redis-tools \
    tesseract-ocr tesseract-ocr-eng libtesseract-dev imagemagick ffmpeg \
    openssh-client rsync jq httpie tmux vim nano tree zip unzip \
    ca-certificates openssl libssl-dev libffi-dev libpq-dev supervisor \
    && rm -rf /var/lib/apt/lists/*

# Node.js 22
RUN curl -fsSL https://deb.nodesource.com/setup_22.x | bash - \
    && apt-get install -y nodejs \
    && npm install -g npm typescript ts-node pnpm yarn vercel railway wrangler

# Python packages - break system packages (dangerous mode)
RUN pip3 install --break-system-packages \
    fastapi "uvicorn[standard]" flask flask-cors httpx requests aiohttp \
    sqlalchemy psycopg2-binary asyncpg redis alembic \
    pandas numpy pillow opencv-python-headless pytesseract \
    pydantic pydantic-settings python-jose "passlib[bcrypt]" python-multipart \
    stripe boto3 paho-mqtt anthropic openai \
    black isort ruff mypy pytest pytest-asyncio \
    python-dotenv click typer rich

# Rust
RUN curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y

# Go
RUN wget -q https://go.dev/dl/go1.22.0.linux-amd64.tar.gz \
    && tar -C /usr/local -xzf go1.22.0.linux-amd64.tar.gz \
    && rm go1.22.0.linux-amd64.tar.gz

# Ruby/Fastlane
RUN gem install fastlane cocoapods

# ============================================
# WORKSPACE SETUP
# ============================================

WORKDIR /workspace

RUN mkdir -p \
    ios/MeterScience/{Models,Views,Services,Resources} \
    api/src/{routes,services,models} \
    api/tests \
    meterpi/tests \
    web/landing \
    docs scripts .claude output

# Git config
RUN git config --global user.email "claude@meterscience.local" \
    && git config --global user.name "Claude Autonomous" \
    && git config --global init.defaultBranch main

# ============================================
# AUTO-EXECUTION SCRIPT
# ============================================

RUN cat > /workspace/scripts/auto-execute.sh << 'SCRIPT'
#!/bin/bash
# MeterScience Autonomous Builder
# Executes entire project build without human intervention

set -e
exec > >(tee -a /workspace/.claude/build.log) 2>&1

echo "========================================"
echo " MeterScience Autonomous Build"
echo " Started: $(date)"
echo "========================================"

cd /workspace

# Initialize git if needed
[ -d .git ] || git init

# ============================================
# PHASE 1: iOS App
# ============================================
echo "[PHASE 1] Building iOS App..."

cat > ios/MeterScience/MeterScienceApp.swift << 'SWIFT'
import SwiftUI

@main
struct MeterScienceApp: App {
    @StateObject private var dataStore = MeterDataStore()
    
    var body: some Scene {
        WindowGroup {
            MainTabView()
                .environmentObject(dataStore)
        }
    }
}
SWIFT

cat > ios/MeterScience/Models/Models.swift << 'SWIFT'
import Foundation
import SwiftUI

// User Profile with Gamification
struct UserProfile: Codable, Identifiable {
    let id: UUID
    var displayName: String
    var avatarEmoji: String
    var level: Int
    var xp: Int
    var totalReadings: Int
    var streakDays: Int
    var trustScore: Int
    var badges: [Badge]
    var subscriptionTier: SubscriptionTier
    var referralCode: String
    var referralCount: Int
    
    init() {
        self.id = UUID()
        self.displayName = "Reader"
        self.avatarEmoji = "üìä"
        self.level = 1
        self.xp = 0
        self.totalReadings = 0
        self.streakDays = 0
        self.trustScore = 50
        self.badges = []
        self.subscriptionTier = .free
        self.referralCode = String((0..<6).map { _ in "ABCDEFGHJKLMNPQRSTUVWXYZ23456789".randomElement()! })
        self.referralCount = 0
    }
    
    var xpForNextLevel: Int { level * 100 + 50 }
    
    mutating func addXP(_ amount: Int) {
        xp += amount
        while xp >= xpForNextLevel {
            xp -= xpForNextLevel
            level += 1
        }
    }
}

struct Badge: Codable, Identifiable {
    let id: String
    let name: String
    let icon: String
    let earnedAt: Date
}

enum SubscriptionTier: String, Codable, CaseIterable {
    case free, neighbor, block, district
    
    var monthlyPrice: Decimal {
        switch self {
        case .free: return 0
        case .neighbor: return 2.99
        case .block: return 4.99
        case .district: return 9.99
        }
    }
}

struct MeterConfig: Codable, Identifiable {
    let id: UUID
    var userId: UUID
    var name: String
    var meterType: MeterType
    var digitCount: Int
    var sampleReadings: [String]
    var createdAt: Date
    var lastReadAt: Date?
}

enum MeterType: String, Codable, CaseIterable {
    case electric, gas, water, solar, other
    
    var icon: String {
        switch self {
        case .electric: return "bolt.fill"
        case .gas: return "flame.fill"
        case .water: return "drop.fill"
        case .solar: return "sun.max.fill"
        case .other: return "gauge"
        }
    }
    
    var unit: String {
        switch self {
        case .electric, .solar: return "kWh"
        case .gas: return "m¬≥"
        case .water: return "gal"
        case .other: return "units"
        }
    }
    
    var color: Color {
        switch self {
        case .electric: return .yellow
        case .gas: return .orange
        case .water: return .blue
        case .solar: return .green
        case .other: return .gray
        }
    }
}

struct MeterReading: Codable, Identifiable {
    let id: UUID
    let meterId: UUID
    let userId: UUID
    let value: String
    let numericValue: Double?
    let confidence: Float
    let timestamp: Date
    var verificationStatus: VerificationStatus
    var usageSinceLast: Double?
}

enum VerificationStatus: String, Codable {
    case pending, verified, disputed, rejected
}

struct Campaign: Codable, Identifiable {
    let id: UUID
    var name: String
    var description: String
    var organizerId: UUID
    var inviteCode: String
    var targetMeterCount: Int
    var participantCount: Int
    var startDate: Date
    var endDate: Date
    var isActive: Bool
}
SWIFT

cat > ios/MeterScience/Services/DataStore.swift << 'SWIFT'
import Foundation
import Combine

class MeterDataStore: ObservableObject {
    @Published var currentUser: UserProfile
    @Published var meters: [MeterConfig] = []
    @Published var readings: [MeterReading] = []
    @Published var campaigns: [Campaign] = []
    @Published var verificationQueue: [MeterReading] = []
    
    private let userKey = "currentUser"
    private let metersKey = "meters"
    private let readingsKey = "readings"
    
    init() {
        if let data = UserDefaults.standard.data(forKey: userKey),
           let user = try? JSONDecoder().decode(UserProfile.self, from: data) {
            currentUser = user
        } else {
            currentUser = UserProfile()
        }
        loadData()
    }
    
    func addMeter(_ meter: MeterConfig) {
        meters.append(meter)
        save()
    }
    
    func addReading(_ reading: MeterReading) {
        readings.append(reading)
        currentUser.totalReadings += 1
        currentUser.addXP(10)
        updateStreak()
        save()
    }
    
    func readings(for meterId: UUID) -> [MeterReading] {
        readings.filter { \$0.meterId == meterId }.sorted { \$0.timestamp > \$1.timestamp }
    }
    
    func submitVerification(readingId: UUID, vote: String) {
        currentUser.verificationsPerformed += 1
        currentUser.addXP(5)
        save()
    }
    
    private func updateStreak() {
        let calendar = Calendar.current
        if let last = currentUser.lastReadingDate,
           calendar.isDateInYesterday(last) {
            currentUser.streakDays += 1
        } else if let last = currentUser.lastReadingDate,
                  !calendar.isDateInToday(last) {
            currentUser.streakDays = 1
        }
        currentUser.lastReadingDate = Date()
    }
    
    private func save() {
        if let data = try? JSONEncoder().encode(currentUser) {
            UserDefaults.standard.set(data, forKey: userKey)
        }
        if let data = try? JSONEncoder().encode(meters) {
            UserDefaults.standard.set(data, forKey: metersKey)
        }
        if let data = try? JSONEncoder().encode(readings) {
            UserDefaults.standard.set(data, forKey: readingsKey)
        }
    }
    
    private func loadData() {
        if let data = UserDefaults.standard.data(forKey: metersKey),
           let decoded = try? JSONDecoder().decode([MeterConfig].self, from: data) {
            meters = decoded
        }
        if let data = UserDefaults.standard.data(forKey: readingsKey),
           let decoded = try? JSONDecoder().decode([MeterReading].self, from: data) {
            readings = decoded
        }
    }
    
    func exportJSON() -> Data? {
        let export = ["user": currentUser, "meters": meters, "readings": readings] as [String : Any]
        return try? JSONSerialization.data(withJSONObject: export)
    }
}
SWIFT

cat > ios/MeterScience/Views/MainTabView.swift << 'SWIFT'
import SwiftUI

struct MainTabView: View {
    @EnvironmentObject var dataStore: MeterDataStore
    
    var body: some View {
        TabView {
            HomeView()
                .tabItem { Label("Home", systemImage: "house.fill") }
            
            NeighborhoodView()
                .tabItem { Label("Neighborhood", systemImage: "map.fill") }
            
            VerifyView()
                .tabItem { Label("Verify", systemImage: "checkmark.seal.fill") }
                .badge(dataStore.verificationQueue.count)
            
            ProfileView()
                .tabItem { Label("Profile", systemImage: "person.circle.fill") }
        }
    }
}

struct HomeView: View {
    @EnvironmentObject var dataStore: MeterDataStore
    @State private var showingScanner = false
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 20) {
                    // Stats Row
                    HStack {
                        StatCard(icon: "flame.fill", value: "\(dataStore.currentUser.streakDays)", label: "Streak", color: .orange)
                        StatCard(icon: "gauge", value: "\(dataStore.currentUser.totalReadings)", label: "Readings", color: .blue)
                        StatCard(icon: "star.fill", value: "Lvl \(dataStore.currentUser.level)", label: "Level", color: .purple)
                    }
                    .padding(.horizontal)
                    
                    // Meters
                    ForEach(dataStore.meters) { meter in
                        MeterCard(meter: meter)
                    }
                    
                    if dataStore.meters.isEmpty {
                        EmptyMeterView()
                    }
                }
                .padding(.vertical)
            }
            .navigationTitle("MeterScience")
        }
    }
}

struct StatCard: View {
    let icon: String
    let value: String
    let label: String
    let color: Color
    
    var body: some View {
        VStack {
            Image(systemName: icon).foregroundColor(color)
            Text(value).font(.headline)
            Text(label).font(.caption).foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(color.opacity(0.1))
        .cornerRadius(12)
    }
}

struct MeterCard: View {
    let meter: MeterConfig
    
    var body: some View {
        HStack {
            Image(systemName: meter.meterType.icon)
                .font(.title)
                .foregroundColor(meter.meterType.color)
            VStack(alignment: .leading) {
                Text(meter.name).font(.headline)
                Text(meter.meterType.rawValue).font(.caption).foregroundColor(.secondary)
            }
            Spacer()
            Button(action: {}) {
                Image(systemName: "camera.fill")
                    .padding()
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(10)
            }
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(16)
        .shadow(radius: 2)
        .padding(.horizontal)
    }
}

struct EmptyMeterView: View {
    var body: some View {
        VStack {
            Image(systemName: "gauge").font(.largeTitle).foregroundColor(.gray)
            Text("No meters yet").font(.headline)
            Text("Add your first meter to start").font(.caption).foregroundColor(.secondary)
        }
        .padding()
    }
}

struct NeighborhoodView: View {
    var body: some View {
        NavigationView {
            Text("Neighborhood Campaigns")
                .navigationTitle("Neighborhood")
        }
    }
}

struct VerifyView: View {
    var body: some View {
        NavigationView {
            Text("Verify Community Readings")
                .navigationTitle("Verify")
        }
    }
}

struct ProfileView: View {
    @EnvironmentObject var dataStore: MeterDataStore
    
    var body: some View {
        NavigationView {
            List {
                Section {
                    HStack {
                        Text(dataStore.currentUser.avatarEmoji).font(.largeTitle)
                        VStack(alignment: .leading) {
                            Text(dataStore.currentUser.displayName).font(.headline)
                            Text("Level \(dataStore.currentUser.level)").font(.caption)
                        }
                    }
                }
                
                Section("Stats") {
                    LabeledContent("Total Readings", value: "\(dataStore.currentUser.totalReadings)")
                    LabeledContent("Current Streak", value: "\(dataStore.currentUser.streakDays) days")
                    LabeledContent("Trust Score", value: "\(dataStore.currentUser.trustScore)%")
                }
                
                Section("Subscription") {
                    LabeledContent("Current Tier", value: dataStore.currentUser.subscriptionTier.rawValue.capitalized)
                    LabeledContent("Referral Code", value: dataStore.currentUser.referralCode)
                }
            }
            .navigationTitle("Profile")
        }
    }
}
SWIFT

echo "[‚úì] iOS App created"

# ============================================
# PHASE 2: API Backend
# ============================================
echo "[PHASE 2] Building API Backend..."

cat > api/requirements.txt << 'REQS'
fastapi>=0.109.0
uvicorn[standard]>=0.27.0
sqlalchemy>=2.0.0
psycopg2-binary>=2.9.0
redis>=5.0.0
pydantic>=2.5.0
pydantic-settings>=2.1.0
python-jose[cryptography]>=3.3.0
passlib[bcrypt]>=1.7.0
stripe>=7.0.0
boto3>=1.34.0
httpx>=0.26.0
python-multipart>=0.0.6
alembic>=1.13.0
pytest>=7.4.0
pytest-asyncio>=0.23.0
REQS

cat > api/src/main.py << 'PYTHON'
"""MeterScience API - Citizen Science Utility Monitoring"""

from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional, List
from uuid import UUID, uuid4
from datetime import datetime
import os

app = FastAPI(
    title="MeterScience API",
    description="Citizen science utility meter reading platform",
    version="1.0.0"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Models
class UserCreate(BaseModel):
    email: str
    display_name: str = "Reader"

class UserResponse(BaseModel):
    id: UUID
    email: str
    display_name: str
    level: int = 1
    xp: int = 0
    subscription_tier: str = "free"
    referral_code: str

class MeterCreate(BaseModel):
    name: str
    meter_type: str
    digit_count: int = 6
    postal_code: Optional[str] = None

class ReadingCreate(BaseModel):
    meter_id: UUID
    value: str
    confidence: float
    capture_method: str = "app"

class ReadingResponse(BaseModel):
    id: UUID
    meter_id: UUID
    value: str
    numeric_value: Optional[float]
    confidence: float
    timestamp: datetime
    verification_status: str = "pending"

# In-memory storage (replace with DB)
users_db = {}
meters_db = {}
readings_db = {}

@app.get("/")
async def root():
    return {"message": "MeterScience API", "version": "1.0.0"}

@app.get("/health")
async def health():
    return {"status": "healthy", "timestamp": datetime.utcnow().isoformat()}

@app.post("/users", response_model=UserResponse)
async def create_user(user: UserCreate):
    user_id = uuid4()
    referral_code = ''.join([c for c in str(uuid4())[:8].upper() if c.isalnum()])
    new_user = {
        "id": user_id,
        "email": user.email,
        "display_name": user.display_name,
        "level": 1,
        "xp": 0,
        "subscription_tier": "free",
        "referral_code": referral_code
    }
    users_db[str(user_id)] = new_user
    return new_user

@app.post("/readings", response_model=ReadingResponse)
async def create_reading(reading: ReadingCreate):
    reading_id = uuid4()
    numeric = None
    try:
        numeric = float(reading.value)
    except:
        pass
    
    new_reading = {
        "id": reading_id,
        "meter_id": reading.meter_id,
        "value": reading.value,
        "numeric_value": numeric,
        "confidence": reading.confidence,
        "timestamp": datetime.utcnow(),
        "verification_status": "pending"
    }
    readings_db[str(reading_id)] = new_reading
    return new_reading

@app.get("/readings", response_model=List[ReadingResponse])
async def list_readings(meter_id: Optional[UUID] = None, limit: int = 100):
    results = list(readings_db.values())
    if meter_id:
        results = [r for r in results if r["meter_id"] == meter_id]
    return results[:limit]

@app.get("/stats/aggregate")
async def aggregate_stats(postal_code: Optional[str] = None):
    total_readings = len(readings_db)
    return {
        "total_readings": total_readings,
        "total_meters": len(meters_db),
        "total_users": len(users_db),
        "postal_code": postal_code
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
PYTHON

echo "[‚úì] API Backend created"

# ============================================
# PHASE 3: MeterPi
# ============================================
echo "[PHASE 3] Building MeterPi..."

cat > meterpi/meterpi.py << 'PYTHON'
#!/usr/bin/env python3
"""MeterPi - Raspberry Pi Meter Reading System"""

import os
import time
import json
import sqlite3
import hashlib
from datetime import datetime
from typing import Optional, Dict, List
from dataclasses import dataclass, asdict
from flask import Flask, jsonify, request
from flask_cors import CORS

try:
    import cv2
    import numpy as np
    import pytesseract
    HAS_CV = True
except ImportError:
    HAS_CV = False
    print("Warning: OpenCV not available")

# Config
CONFIG = {
    "capture_interval_seconds": 60,
    "api_port": 5000,
    "db_path": "./readings.db",
    "expected_digits": 6,
    "min_confidence": 0.7,
    "consensus_frames": 3,
}

@dataclass
class Reading:
    reading_id: str
    value: str
    numeric_value: Optional[float]
    confidence: float
    timestamp: str
    
    def to_dict(self):
        return asdict(self)

class Database:
    def __init__(self, path: str):
        self.path = path
        self._init()
    
    def _init(self):
        conn = sqlite3.connect(self.path)
        conn.execute("""
            CREATE TABLE IF NOT EXISTS readings (
                reading_id TEXT PRIMARY KEY,
                value TEXT NOT NULL,
                numeric_value REAL,
                confidence REAL,
                timestamp TEXT
            )
        """)
        conn.commit()
        conn.close()
    
    def save(self, reading: Reading):
        conn = sqlite3.connect(self.path)
        conn.execute(
            "INSERT INTO readings VALUES (?, ?, ?, ?, ?)",
            (reading.reading_id, reading.value, reading.numeric_value,
             reading.confidence, reading.timestamp)
        )
        conn.commit()
        conn.close()
    
    def get_latest(self) -> Optional[Dict]:
        conn = sqlite3.connect(self.path)
        conn.row_factory = sqlite3.Row
        cur = conn.execute("SELECT * FROM readings ORDER BY timestamp DESC LIMIT 1")
        row = cur.fetchone()
        conn.close()
        return dict(row) if row else None
    
    def get_range(self, from_ts: str, to_ts: str) -> List[Dict]:
        conn = sqlite3.connect(self.path)
        conn.row_factory = sqlite3.Row
        cur = conn.execute(
            "SELECT * FROM readings WHERE timestamp >= ? AND timestamp <= ? ORDER BY timestamp DESC",
            (from_ts, to_ts)
        )
        rows = cur.fetchall()
        conn.close()
        return [dict(r) for r in rows]
    
    def get_stats(self) -> Dict:
        conn = sqlite3.connect(self.path)
        total = conn.execute("SELECT COUNT(*) FROM readings").fetchone()[0]
        latest = conn.execute("SELECT timestamp FROM readings ORDER BY timestamp DESC LIMIT 1").fetchone()
        conn.close()
        return {
            "total_readings": total,
            "latest_reading": latest[0] if latest else None
        }

class OCREngine:
    def __init__(self, expected_digits: int = 6):
        self.expected_digits = expected_digits
    
    def process(self, frame) -> Optional[Dict]:
        if not HAS_CV:
            return None
        
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
        enhanced = clahe.apply(gray)
        _, binary = cv2.threshold(enhanced, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
        
        config = '--psm 7 -c tessedit_char_whitelist=0123456789'
        data = pytesseract.image_to_data(binary, config=config, output_type=pytesseract.Output.DICT)
        
        for i, text in enumerate(data['text']):
            digits = ''.join(c for c in text if c.isdigit())
            if len(digits) >= 4:
                conf = float(data['conf'][i]) / 100.0
                return {"value": digits, "confidence": conf}
        
        return None

# Flask API
app = Flask(__name__)
CORS(app)
db = Database(CONFIG["db_path"])

@app.route('/api/v1/readings/latest')
def get_latest():
    reading = db.get_latest()
    return jsonify(reading) if reading else jsonify({"error": "No readings"}), 404

@app.route('/api/v1/readings')
def get_readings():
    from_ts = request.args.get('from', '2000-01-01')
    to_ts = request.args.get('to', '2100-01-01')
    readings = db.get_range(from_ts, to_ts)
    return jsonify({"readings": readings, "count": len(readings)})

@app.route('/api/v1/stats')
def get_stats():
    stats = db.get_stats()
    return jsonify(stats)

@app.route('/api/v1/health')
def health():
    return jsonify({"status": "healthy", "ocr_available": HAS_CV})

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--api-only', action='store_true')
    args = parser.parse_args()
    
    print(f"Starting MeterPi API on port {CONFIG['api_port']}")
    app.run(host='0.0.0.0', port=CONFIG['api_port'])
PYTHON

cat > meterpi/requirements.txt << 'REQS'
opencv-python-headless>=4.8.0
pytesseract>=0.3.10
numpy>=1.24.0
flask>=3.0.0
flask-cors>=4.0.0
paho-mqtt>=1.6.0
requests>=2.31.0
pillow>=10.0.0
REQS

cat > meterpi/install.sh << 'BASH'
#!/bin/bash
set -e
echo "Installing MeterPi..."
sudo apt-get update
sudo apt-get install -y python3-pip python3-opencv tesseract-ocr
pip3 install -r requirements.txt --break-system-packages
echo "MeterPi installed!"
BASH
chmod +x meterpi/install.sh

echo "[‚úì] MeterPi created"

# ============================================
# PHASE 4: Database Schema
# ============================================
echo "[PHASE 4] Creating database schema..."

cat > scripts/init-db.sql << 'SQL'
-- MeterScience Database Schema
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "postgis";

CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email VARCHAR(255) UNIQUE,
    display_name VARCHAR(100) DEFAULT 'Reader',
    level INTEGER DEFAULT 1,
    xp INTEGER DEFAULT 0,
    total_readings INTEGER DEFAULT 0,
    streak_days INTEGER DEFAULT 0,
    trust_score INTEGER DEFAULT 50,
    subscription_tier VARCHAR(20) DEFAULT 'free',
    referral_code VARCHAR(10) UNIQUE,
    postal_code VARCHAR(20),
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE meters (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(id),
    name VARCHAR(100),
    meter_type VARCHAR(20),
    digit_count INTEGER DEFAULT 6,
    postal_code VARCHAR(20),
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE readings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    meter_id UUID REFERENCES meters(id),
    user_id UUID REFERENCES users(id),
    value VARCHAR(50),
    numeric_value DECIMAL(15,3),
    confidence REAL,
    timestamp TIMESTAMP DEFAULT NOW(),
    verification_status VARCHAR(20) DEFAULT 'pending'
);

CREATE TABLE campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(200),
    organizer_id UUID REFERENCES users(id),
    invite_code VARCHAR(10) UNIQUE,
    target_meter_count INTEGER,
    start_date TIMESTAMP,
    end_date TIMESTAMP,
    is_active BOOLEAN DEFAULT TRUE
);

CREATE INDEX idx_readings_meter ON readings(meter_id);
CREATE INDEX idx_readings_timestamp ON readings(timestamp DESC);
SQL

echo "[‚úì] Database schema created"

# ============================================
# PHASE 5: Docker Compose
# ============================================
echo "[PHASE 5] Creating Docker Compose..."

cat > docker-compose.yml << 'YAML'
version: '3.9'
services:
  api:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://meterscience:meterscience@db:5432/meterscience
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis
    command: uvicorn api.src.main:app --host 0.0.0.0 --port 8000

  db:
    image: postgis/postgis:16-3.4
    environment:
      POSTGRES_USER: meterscience
      POSTGRES_PASSWORD: meterscience
      POSTGRES_DB: meterscience
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  meterpi:
    build: .
    ports:
      - "5000:5000"
    command: python meterpi/meterpi.py --api-only

volumes:
  postgres_data:
YAML

echo "[‚úì] Docker Compose created"

# ============================================
# PHASE 6: Landing Page
# ============================================
echo "[PHASE 6] Creating landing page..."

cat > web/landing/index.html << 'HTML'
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MeterScience - Citizen Science Utility Monitoring</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gradient-to-br from-green-50 to-blue-50 min-h-screen">
    <nav class="bg-white/80 backdrop-blur-sm shadow-sm sticky top-0 z-50">
        <div class="max-w-6xl mx-auto px-4 py-4 flex justify-between items-center">
            <div class="text-2xl font-bold text-green-600">‚ö° MeterScience</div>
            <div class="space-x-6">
                <a href="#features" class="text-gray-600 hover:text-green-600">Features</a>
                <a href="#pricing" class="text-gray-600 hover:text-green-600">Pricing</a>
                <a href="#hardware" class="text-gray-600 hover:text-green-600">MeterPi</a>
                <a href="#waitlist" class="bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700">Join Waitlist</a>
            </div>
        </div>
    </nav>
    
    <main class="max-w-6xl mx-auto px-4 py-20">
        <div class="text-center mb-20">
            <h1 class="text-5xl font-bold text-gray-900 mb-6">
                Citizen Science for<br>Your Utility Bills
            </h1>
            <p class="text-xl text-gray-600 mb-8 max-w-2xl mx-auto">
                Scan your meters, track your usage, and unlock neighborhood insights 
                that utilities can't provide. <strong>Your data is always free.</strong>
            </p>
            <div class="flex justify-center gap-4">
                <a href="#waitlist" class="bg-green-600 text-white px-8 py-4 rounded-xl text-lg font-semibold hover:bg-green-700 shadow-lg">
                    Join the Waitlist ‚Üí
                </a>
                <a href="#demo" class="bg-white text-gray-700 px-8 py-4 rounded-xl text-lg font-semibold border hover:bg-gray-50">
                    Watch Demo
                </a>
            </div>
        </div>
        
        <section id="features" class="mb-20">
            <h2 class="text-3xl font-bold text-center mb-12">Why MeterScience?</h2>
            <div class="grid md:grid-cols-3 gap-8">
                <div class="bg-white p-8 rounded-2xl shadow-lg">
                    <div class="text-4xl mb-4">üì±</div>
                    <h3 class="text-xl font-semibold mb-2">AI-Powered Scanning</h3>
                    <p class="text-gray-600">Point your phone at any meter. Our Vision AI reads it instantly with 99% accuracy.</p>
                </div>
                <div class="bg-white p-8 rounded-2xl shadow-lg">
                    <div class="text-4xl mb-4">üèòÔ∏è</div>
                    <h3 class="text-xl font-semibold mb-2">Neighbor Comparisons</h3>
                    <p class="text-gray-600">See how your usage compares. Find savings opportunities others miss.</p>
                </div>
                <div class="bg-white p-8 rounded-2xl shadow-lg">
                    <div class="text-4xl mb-4">üî¨</div>
                    <h3 class="text-xl font-semibold mb-2">Citizen Science</h3>
                    <p class="text-gray-600">Contribute to research. Help your community understand energy patterns.</p>
                </div>
            </div>
        </section>
        
        <section id="pricing" class="mb-20">
            <h2 class="text-3xl font-bold text-center mb-4">Simple Pricing</h2>
            <p class="text-center text-gray-600 mb-12">Your own data is always free. Pay only for neighbor insights.</p>
            <div class="grid md:grid-cols-4 gap-6">
                <div class="bg-white p-6 rounded-2xl shadow">
                    <div class="text-2xl font-bold mb-2">Free</div>
                    <div class="text-4xl font-bold text-green-600 mb-4">$0</div>
                    <ul class="text-gray-600 space-y-2 text-sm">
                        <li>‚úì Unlimited personal readings</li>
                        <li>‚úì Usage tracking</li>
                        <li>‚úì Gamification</li>
                        <li>‚úó Neighbor data</li>
                    </ul>
                </div>
                <div class="bg-white p-6 rounded-2xl shadow">
                    <div class="text-2xl font-bold mb-2">Neighbor</div>
                    <div class="text-4xl font-bold text-green-600 mb-4">$2.99<span class="text-lg">/mo</span></div>
                    <ul class="text-gray-600 space-y-2 text-sm">
                        <li>‚úì Everything in Free</li>
                        <li>‚úì Postal code comparisons</li>
                        <li>‚úì Anonymous trends</li>
                    </ul>
                </div>
                <div class="bg-white p-6 rounded-2xl shadow border-2 border-green-500 relative">
                    <div class="absolute -top-3 left-1/2 -translate-x-1/2 bg-green-500 text-white text-xs px-3 py-1 rounded-full">POPULAR</div>
                    <div class="text-2xl font-bold mb-2">Block</div>
                    <div class="text-4xl font-bold text-green-600 mb-4">$4.99<span class="text-lg">/mo</span></div>
                    <ul class="text-gray-600 space-y-2 text-sm">
                        <li>‚úì 5km radius data</li>
                        <li>‚úì Create campaigns</li>
                        <li>‚úì CSV export</li>
                    </ul>
                </div>
                <div class="bg-white p-6 rounded-2xl shadow">
                    <div class="text-2xl font-bold mb-2">District</div>
                    <div class="text-4xl font-bold text-green-600 mb-4">$9.99<span class="text-lg">/mo</span></div>
                    <ul class="text-gray-600 space-y-2 text-sm">
                        <li>‚úì 25km radius data</li>
                        <li>‚úì Full API access</li>
                        <li>‚úì Webhooks</li>
                    </ul>
                </div>
            </div>
        </section>
        
        <section id="waitlist" class="bg-green-600 rounded-3xl p-12 text-center text-white">
            <h2 class="text-3xl font-bold mb-4">Get Early Access</h2>
            <p class="mb-8 text-green-100">Join 2,847 others on the waitlist</p>
            <form class="flex max-w-md mx-auto gap-2">
                <input type="email" placeholder="Enter your email" class="flex-1 px-4 py-3 rounded-lg text-gray-900">
                <button class="bg-gray-900 px-6 py-3 rounded-lg font-semibold hover:bg-gray-800">Join</button>
            </form>
        </section>
    </main>
    
    <footer class="bg-gray-900 text-gray-400 py-8 mt-20">
        <div class="max-w-6xl mx-auto px-4 text-center">
            <p>¬© 2024 MeterScience by EcoWorks Web Architecture Inc.</p>
        </div>
    </footer>
</body>
</html>
HTML

echo "[‚úì] Landing page created"

# ============================================
# PHASE 7: Documentation
# ============================================
echo "[PHASE 7] Creating documentation..."

cat > README.md << 'MD'
# üî¨ MeterScience

**Citizen Science Utility Monitoring Platform**

Scan your meters, track your usage, unlock neighborhood insights. Your data is always free.

## Quick Start

```bash
# Start all services
docker-compose up -d

# API: http://localhost:8000
# MeterPi: http://localhost:5000
# DB: localhost:5432
```

## Components

- **iOS App** - SwiftUI + Vision framework OCR
- **API** - FastAPI + PostgreSQL
- **MeterPi** - Raspberry Pi hardware kit
- **Web** - Landing page

## Pricing

| Tier | Price | Data Access |
|------|-------|-------------|
| Free | $0 | Your data only |
| Neighbor | $2.99/mo | Postal code |
| Block | $4.99/mo | 5km radius |
| District | $9.99/mo | 25km + API |

## License

MIT
MD

cat > CLAUDE.md << 'MD'
# MeterScience - Claude Code Context

## What This Is
Citizen science platform for crowdsourced utility meter reading.

## Tech Stack
- iOS: SwiftUI + Vision framework
- API: FastAPI + PostgreSQL + Redis
- Hardware: Raspberry Pi + OpenCV + Tesseract

## Key Files
- `ios/` - Complete iOS app
- `api/` - FastAPI backend
- `meterpi/` - Raspberry Pi software
- `scripts/` - Automation

## Business Model
- Free: Your own data
- Paid: Neighbor comparisons ($2.99-$9.99/mo)
- Referrals: 10 = Block tier for life

## Commands
```bash
./scripts/auto-execute.sh  # Build everything
docker-compose up -d       # Start services
```
MD

echo "[‚úì] Documentation created"

# ============================================
# FINALIZE
# ============================================
echo "[PHASE 8] Finalizing..."

# Git commit
git add -A
git commit -m "Autonomous build: Complete MeterScience platform

- iOS app with SwiftUI
- FastAPI backend
- MeterPi Raspberry Pi software
- PostgreSQL schema
- Landing page
- Documentation

Built by Claude autonomous executor"

echo ""
echo "========================================"
echo " BUILD COMPLETE!"
echo " Finished: $(date)"
echo "========================================"
echo ""
echo "Services:"
echo "  API:     http://localhost:8000"
echo "  MeterPi: http://localhost:5000"
echo "  Web:     file://$(pwd)/web/landing/index.html"
echo ""
echo "Start everything:"
echo "  docker-compose up -d"
echo ""
SCRIPT
chmod +x /workspace/scripts/auto-execute.sh

# ============================================
# ENTRYPOINT
# ============================================

COPY <<EOF /entrypoint.sh
#!/bin/bash
echo "========================================"
echo " MeterScience DANGEROUS Sandbox"
echo " ‚ö†Ô∏è  ZERO RESTRICTIONS ENABLED"
echo "========================================"
echo ""
echo "Quick start:"
echo "  ./scripts/auto-execute.sh  - Build everything"
echo "  docker-compose up -d       - Start services"
echo ""

# Auto-execute if requested
if [ "\$1" = "auto" ]; then
    /workspace/scripts/auto-execute.sh
else
    exec "\$@"
fi
EOF
chmod +x /entrypoint.sh

EXPOSE 3000 5000 8000 5432 6379

ENTRYPOINT ["/entrypoint.sh"]
CMD ["/bin/bash"]
